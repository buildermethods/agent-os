---
description: PEER Pattern Process Coordination for Agent OS
globs:
alwaysApply: false
version: 2.0
encoding: UTF-8
---

# PEER Pattern Execution

## Overview

IMPORTANT: Before doing anything output the version present at the top of this file. ALWAYS.

Orchestrate any Agent OS instruction through the PEER (Plan, Execute, Express, Review) pattern for improved task decomposition, execution quality, and output consistency using process-based coordination. As the coordinator, delegate all file operations to subagents while maintaining state through NATS KV.

<pre_flight_check>
  EXECUTE: @~/.agent-os/instructions/meta/pre-flight.md
</pre_flight_check>

<process_flow>

<step number="1" name="nats_availability_check">

### Step 1: NATS Server Availability Check

Verify NATS server is available before proceeding with PEER pattern execution.

<validation_logic>
  CHECK: NATS server connectivity
  IF server not responding:
    ERROR: "❌ NATS server is not available"
    PROVIDE: "Please ensure NATS server is running before using /peer"
    STOP execution
  ELSE:
    PROCEED to next step
</validation_logic>

<nats_health_command>
  nats kv ls --timeout=5s
</nats_health_command>

<failure_handler name="nats_unavailable">
  <actions>
    - LOG: "NATS server check failed"
    - DISPLAY: "❌ NATS server is not available. Please ensure NATS server is running before using /peer"
    - STOP: Execution immediately
  </actions>
</failure_handler>

<instructions>
  ACTION: Verify NATS server availability
  VALIDATION: Ensure KV operations are accessible
  ERROR_HANDLING: Stop execution if server unavailable
</instructions>

</step>
  
<step number="2" name="kv_bucket_verification">

### Step 2: KV Bucket Verification

Ensure the agent-os-peer-state bucket exists with correct configuration for PEER state management.

<bucket_check_logic>
  CHECK: Bucket existence and configuration
  IF bucket does not exist:
    ACTION: Create bucket with required configuration
    IF creation fails:
      ERROR: "❌ Failed to create KV bucket. Check NATS server permissions"
      STOP execution
  ELSE IF configuration mismatch:
    WARN: "⚠️ Bucket configuration differs from requirements"
    PROVIDE: "Current config may affect reliability"
    PROCEED with warning
</bucket_check_logic>

<bucket_configuration>
  nats kv add agent-os-peer-state --replicas=3 --history=50 --description="PEER pattern state storage for Agent OS"
</bucket_configuration>

<failure_handler name="bucket_creation_failed">
  <actions>
    - LOG: "Failed to create NATS KV bucket: agent-os-peer-state"
    - DISPLAY: "❌ Failed to create KV bucket. Check NATS server permissions"
    - STOP: Execution immediately
  </actions>
</failure_handler>

<instructions>
  ACTION: Verify or create NATS KV bucket
  VALIDATE: Bucket exists with proper configuration
  HANDLE: Creation failures and config mismatches
</instructions>

</step>
  
<step number="3" name="argument_parsing">

### Step 3: Parse and Validate Arguments

Parse command arguments to determine execution mode and validate required parameters.

<argument_validation>
  <required_parameters>
    - --instruction=<name> OR --continue (mutually exclusive)
    - --spec=<name> (optional)
  </required_parameters>
  
  <validation_logic>
    IF neither --instruction nor --continue provided:
      ERROR: "Must provide either --instruction or --continue"
      DISPLAY: "Usage: /peer --instruction=<name> [--spec=<name>]"
      DISPLAY: "   or: /peer --continue"
      STOP execution
    IF both --instruction and --continue provided:
      ERROR: "Cannot use both --instruction and --continue"
      STOP execution
  </validation_logic>
</argument_validation>

<context_variables>
  - PEER_MODE: "new" or "continue"
  - INSTRUCTION_NAME: from --instruction flag
  - SPEC_NAME: from --spec flag (optional)
</context_variables>

<context_storage>
  STORE in NATS KV: peer.context.current_execution.peer_mode = "[PEER_MODE]"
  STORE in NATS KV: peer.context.current_execution.instruction_name = "[INSTRUCTION_NAME]"
  STORE in NATS KV: peer.context.current_execution.spec_name = "[SPEC_NAME]"
</context_storage>

<failure_handler name="invalid_arguments">
  <actions>
    - LOG: "Invalid command arguments provided"
    - DISPLAY: Error message based on validation failure
    - STOP: Execution immediately
  </actions>
</failure_handler>

<instructions>
  ACTION: Parse command line arguments
  VALIDATE: Ensure valid argument combination
  STORE: Execution mode and parameters in NATS KV
</instructions>

</step>
  
<step number="4" name="execution_context_determination">

### Step 4: Determine Execution Context

Classify the instruction and determine spec context if applicable.

<context_classification>
  <spec_aware_instructions>
    - create-spec
    - execute-tasks
    - analyze-product
  </spec_aware_instructions>
  
  <classification_logic>
    IF INSTRUCTION_NAME in spec_aware_instructions:
      SET: SPEC_AWARE = true
      IF SPEC_NAME not provided AND INSTRUCTION_NAME requires spec:
        ERROR: "Spec name required for [INSTRUCTION_NAME]"
        STOP execution
    ELSE:
      SET: SPEC_AWARE = false
  </classification_logic>
</context_classification>

<nats_key_prefix>
  IF SPEC_AWARE and SPEC_NAME provided:
    KEY_PREFIX: "peer.spec.[SPEC_NAME]"
  ELSE:
    KEY_PREFIX: "peer.global"
</nats_key_prefix>

<storage>
  STORE in NATS KV: peer.context.current_execution.spec_aware = "[SPEC_AWARE]"
  STORE in NATS KV: peer.context.current_execution.key_prefix = "[KEY_PREFIX]"
</storage>

<failure_handler name="missing_spec_name">
  <actions>
    - LOG: "Spec name required for instruction: [INSTRUCTION_NAME]"
    - DISPLAY: "ERROR: Spec name required for [INSTRUCTION_NAME]. Use --spec=<name>"
    - STOP: Execution immediately
  </actions>
</failure_handler>

<instructions>
  ACTION: Determine instruction context
  CLASSIFY: As spec-aware or non-spec
  ESTABLISH: NATS key prefix for state management
  STORE: Context classification in NATS KV
</instructions>

</step>
  
<step number="5" name="cycle_initialization">

### Step 5: Initialize PEER Cycle

Create or determine the PEER cycle for this execution and set up initial state.

<cycle_logic>
  IF PEER_MODE is "continue":
    FIND: Last incomplete cycle from NATS KV
    IF found:
      LOAD: Cycle metadata
      RESUME: From last completed phase
    ELSE:
      ERROR: "No incomplete cycle found to continue"
      PROVIDE: "Start a new cycle with --instruction"
      STOP execution
  ELSE:
    CREATE: New cycle with incremented number
    INITIALIZE: Cycle metadata in NATS KV
</cycle_logic>

<cycle_metadata>
  - cycle_number: Sequential identifier
  - instruction: Target instruction name
  - spec: Spec name if applicable
  - status: "initialized"
  - phases_completed: []
  - created_at: Current timestamp
</cycle_metadata>

<cycle_state_storage>
  STORE in NATS KV: [KEY_PREFIX].cycle.current = "[CYCLE_NUMBER]"
  STORE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].metadata = {
    "cycle_number": [CYCLE_NUMBER],
    "instruction": "[INSTRUCTION_NAME]",
    "spec": "[SPEC_NAME]",
    "status": "initialized",
    "phases_completed": [],
    "created_at": "[TIMESTAMP]"
  }
</cycle_state_storage>

<failure_handler name="cycle_initialization_failed">
  <actions>
    - LOG: "Failed to initialize PEER cycle"
    - UPDATE in NATS KV: peer.context.current_execution.error = "cycle_init_failed"
    - DISPLAY: "❌ Failed to initialize PEER cycle. Check NATS KV state."
    - STOP: Execution immediately
  </actions>
</failure_handler>

<instructions>
  ACTION: Initialize or resume PEER cycle
  DETERMINE: New cycle or continuation
  STORE: Cycle metadata for phase coordination
  OUTPUT: Cycle number and initial status
</instructions>

</step>
  
<step number="6" name="spec_name_determination">

### Step 6: Spec Name Determination (Conditional)

For create-spec instructions, determine an appropriate spec name from user requirements.

<conditional_execution>
  IF INSTRUCTION_NAME != "create-spec":
    SKIP this entire step
    PROCEED to step 7
</conditional_execution>

<spec_name_logic>
  IF SPEC_NAME already provided via --spec:
    USE: Provided spec name
  ELSE:
    ANALYZE: User requirements from initial input
    EXTRACT: 3-5 meaningful keywords
    REMOVE: Common words (the, a, an, is, are, and, or, for, to, of, in, on, at, by, with)
    FORMAT: Convert to kebab-case
    LIMIT: Maximum 5 words
    DEFAULT: "new-feature" if extraction fails
</spec_name_logic>

<storage>
  STORE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].context.determined_spec_name = "[SPEC_NAME]"
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].metadata.spec = "[SPEC_NAME]"
</storage>

<instructions>
  ACTION: Determine spec name for create-spec instruction
  PROCESS: Extract from user requirements or use provided name
  STORE: In cycle metadata for downstream phases
</instructions>

</step>
  
<step number="7" subagent="peer-planner" name="planning_phase">

### Step 7: Planning Phase

Use the peer-planner subagent to decompose the instruction into manageable phases and create an execution plan.

<planning_context>
  INSTRUCTION: [INSTRUCTION_NAME]
  SPEC_NAME: [SPEC_NAME] (if applicable)
  CYCLE_NUMBER: [CYCLE_NUMBER]
  KEY_PREFIX: [KEY_PREFIX]
</planning_context>

<subagent_atomicity>
  OUTPUT_KEY: [KEY_PREFIX].cycle.[CYCLE_NUMBER].plan
  SUMMARY_KEY: [KEY_PREFIX].cycle.[CYCLE_NUMBER].plan_summary
</subagent_atomicity>

<instructions>
  ACTION: Use peer-planner subagent
  REQUEST: "Create execution plan for instruction: [INSTRUCTION_NAME]
            Cycle: [CYCLE_NUMBER]
            Spec: [SPEC_NAME] (if applicable)
            
            Context:
            - NATS KV Bucket: agent-os-peer-state
            - Output Key: [OUTPUT_KEY]
            - Summary Key: [SUMMARY_KEY]
            - Key Prefix: [KEY_PREFIX]
            - Execution Mode: [PEER_MODE]
            
            Requirements:
            1. Analyze the target instruction located at:
               @~/.agent-os/instructions/core/[INSTRUCTION_NAME].md
            
            2. Create a comprehensive execution plan that includes:
               - Breakdown of work into logical phases
               - Success criteria for each phase
               - Expected deliverables
               - Dependencies and prerequisites
               - Risk assessment and mitigation strategies
            
            3. Persist the plan directly to NATS KV at: [OUTPUT_KEY]
            
            4. Store a planning summary at: [SUMMARY_KEY]
            
            Your final action must be to confirm persistence by storing 'completed' at:
            [KEY_PREFIX].cycle.[CYCLE_NUMBER].phases.planning = 'completed'"
  WAIT: For key [KEY_PREFIX].cycle.[CYCLE_NUMBER].phases.planning to equal 'completed'
  VALIDATE: Plan exists at [OUTPUT_KEY]
</instructions>

<phase_completion>
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].metadata.phases_completed += ["planning"]
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].status = "planning_complete"
</phase_completion>

<failure_handler name="planning_phase_failed">
  <actions>
    - LOG: "PEER Planning failed for cycle [CYCLE_NUMBER]"
    - UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].status = "PLANNING_FAILED"
    - UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].failed_at = "[TIMESTAMP]"
    - DISPLAY: "❌ Planning phase failed. Check subagent output for details."
    - STOP: Execution immediately
  </actions>
</failure_handler>

</step>
  
<step number="8" subagent="peer-executor" name="execution_phase">

### Step 8: Execution Phase

Use the peer-executor subagent to execute the planned instruction using appropriate Agent OS patterns.

<phase_validation>
  CHECK: Planning phase completed
  VERIFY key exists: [KEY_PREFIX].cycle.[CYCLE_NUMBER].plan
  IF plan not available:
    ERROR: "Cannot execute without completed planning phase"
    PROVIDE: "Ensure planning phase completed successfully"
    STOP execution
</phase_validation>

<execution_context>
  INSTRUCTION: [INSTRUCTION_NAME]
  SPEC_NAME: [SPEC_NAME] (if applicable)
  CYCLE_NUMBER: [CYCLE_NUMBER]
  KEY_PREFIX: [KEY_PREFIX]
  PLAN_LOCATION: [KEY_PREFIX].cycle.[CYCLE_NUMBER].plan
</execution_context>

<subagent_atomicity>
  OUTPUT_KEY: [KEY_PREFIX].cycle.[CYCLE_NUMBER].execution
  DELIVERABLES_KEY: [KEY_PREFIX].cycle.[CYCLE_NUMBER].deliverables
</subagent_atomicity>

<instructions>
  ACTION: Use peer-executor subagent
  REQUEST: "Execute instruction: [INSTRUCTION_NAME]
            Using plan from: [PLAN_LOCATION]
            Cycle: [CYCLE_NUMBER]
            
            Context:
            - NATS KV Bucket: agent-os-peer-state
            - Plan Location: [PLAN_LOCATION]
            - Output Key: [OUTPUT_KEY]
            - Deliverables Key: [DELIVERABLES_KEY]
            - Spec Name: [SPEC_NAME] (if applicable)
            - Key Prefix: [KEY_PREFIX]
            
            Follow the execution plan and implement the instruction
            according to Agent OS patterns. Capture all outputs,
            user interactions, and results.
            
            Persist execution results directly to: [OUTPUT_KEY]
            Store key deliverables at: [DELIVERABLES_KEY]
            
            Your final action must be to confirm persistence by storing 'completed' at:
            [KEY_PREFIX].cycle.[CYCLE_NUMBER].phases.execution = 'completed'"
  WAIT: For key [KEY_PREFIX].cycle.[CYCLE_NUMBER].phases.execution to equal 'completed'
  VALIDATE: Execution results exist at [OUTPUT_KEY]
</instructions>

<phase_completion>
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].metadata.phases_completed += ["execution"]
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].status = "execution_complete"
</phase_completion>

<failure_handler name="execution_phase_failed">
  <actions>
    - LOG: "PEER Execution failed for cycle [CYCLE_NUMBER]"
    - UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].status = "EXECUTION_FAILED"
    - UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].failed_at = "[TIMESTAMP]"
    - UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].error = "execution_failed"
    - DISPLAY: "❌ Execution phase failed. Check subagent output for details."
    - STOP: Execution immediately
  </actions>
</failure_handler>

</step>
  
<step number="9" subagent="peer-express" name="express_phase">

### Step 9: Express Phase

Use the peer-express subagent to format and present the execution results professionally.

<phase_validation>
  CHECK: Execution phase completed
  VERIFY key exists: [KEY_PREFIX].cycle.[CYCLE_NUMBER].execution
  IF execution results not available:
    ERROR: "Cannot express without completed execution phase"
    PROVIDE: "Ensure execution phase completed successfully"
    STOP execution
</phase_validation>

<express_context>
  CYCLE_NUMBER: [CYCLE_NUMBER]
  KEY_PREFIX: [KEY_PREFIX]
  PLAN_LOCATION: [KEY_PREFIX].cycle.[CYCLE_NUMBER].plan
  EXECUTION_LOCATION: [KEY_PREFIX].cycle.[CYCLE_NUMBER].execution
  DELIVERABLES_LOCATION: [KEY_PREFIX].cycle.[CYCLE_NUMBER].deliverables
</express_context>

<subagent_atomicity>
  OUTPUT_KEY: [KEY_PREFIX].cycle.[CYCLE_NUMBER].express
  SUMMARY_KEY: [KEY_PREFIX].cycle.[CYCLE_NUMBER].express_summary
</subagent_atomicity>

<instructions>
  ACTION: Use peer-express subagent
  REQUEST: "Format execution results for cycle: [CYCLE_NUMBER]
            Plan available at: [PLAN_LOCATION]
            Execution results at: [EXECUTION_LOCATION]
            Deliverables at: [DELIVERABLES_LOCATION]
            
            Context:
            - Output Key: [OUTPUT_KEY]
            - Summary Key: [SUMMARY_KEY]
            
            Create a clear, professional presentation of the work
            completed, highlighting key achievements, deliverables,
            and outcomes.
            
            Persist formatted output directly to: [OUTPUT_KEY]
            Store express summary at: [SUMMARY_KEY]
            
            Your final action must be to confirm persistence by storing 'completed' at:
            [KEY_PREFIX].cycle.[CYCLE_NUMBER].phases.express = 'completed'"
  WAIT: For key [KEY_PREFIX].cycle.[CYCLE_NUMBER].phases.express to equal 'completed'
  PROCESS: Display formatted results to user
</instructions>

<phase_completion>
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].metadata.phases_completed += ["express"]
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].status = "express_complete"
</phase_completion>

<failure_handler name="express_phase_failed">
  <actions>
    - LOG: "PEER Express failed for cycle [CYCLE_NUMBER]"
    - UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].status = "EXPRESS_FAILED"
    - UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].failed_at = "[TIMESTAMP]"
    - DISPLAY: "❌ Express phase failed. Check subagent output for details."
    - STOP: Execution immediately
  </actions>
</failure_handler>

</step>
  
<step number="10" subagent="peer-review" name="review_phase">

### Step 10: Review Phase

Use the peer-review subagent to assess execution quality and provide improvement recommendations.

<review_criteria_fetch>
  RETRIEVE from NATS KV: criteria.[INSTRUCTION_NAME]
  IF not found:
    USE: Default review criteria based on instruction type
  STORE as: REVIEW_CRITERIA
</review_criteria_fetch>

<review_context>
  CYCLE_NUMBER: [CYCLE_NUMBER]
  KEY_PREFIX: [KEY_PREFIX]
  INSTRUCTION: [INSTRUCTION_NAME]
  ALL_PHASES: Available in NATS KV under cycle prefix
  REVIEW_CRITERIA: [REVIEW_CRITERIA]
</review_context>

<review_considerations>
  FOR create-spec: Focus on spec completeness and clarity
  FOR execute-tasks: Assess task completion and code quality
  FOR analyze-product: Evaluate analysis depth and insights
  FOR plan-product: Review planning comprehensiveness
  FOR git-commit: Validate commit quality and workflow
  DEFAULT: General quality and completeness review
</review_considerations>

<subagent_atomicity>
  OUTPUT_KEY: [KEY_PREFIX].cycle.[CYCLE_NUMBER].review
  SUMMARY_KEY: [KEY_PREFIX].cycle.[CYCLE_NUMBER].review_summary
  IMPROVEMENTS_KEY: [KEY_PREFIX].cycle.[CYCLE_NUMBER].improvements
</subagent_atomicity>

<instructions>
  ACTION: Use peer-review subagent
  REQUEST: "Review PEER execution for cycle: [CYCLE_NUMBER]
            Instruction: [INSTRUCTION_NAME]
            Review Criteria: [REVIEW_CRITERIA]
            
            Access all phase outputs from NATS KV prefix:
            [KEY_PREFIX].cycle.[CYCLE_NUMBER].*
            
            Context:
            - Output Key: [OUTPUT_KEY]
            - Summary Key: [SUMMARY_KEY]
            - Improvements Key: [IMPROVEMENTS_KEY]
            
            Assess execution quality, identify improvements,
            and provide recommendations for future cycles.
            
            Persist review results directly to: [OUTPUT_KEY]
            Store review summary at: [SUMMARY_KEY]
            Store improvement recommendations at: [IMPROVEMENTS_KEY]
            
            Your final action must be to confirm persistence by storing 'completed' at:
            [KEY_PREFIX].cycle.[CYCLE_NUMBER].phases.review = 'completed'"
  WAIT: For key [KEY_PREFIX].cycle.[CYCLE_NUMBER].phases.review to equal 'completed'
  PROCESS: Share insights for continuous improvement
</instructions>

<phase_completion>
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].metadata.phases_completed += ["review"]
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].status = "review_complete"
</phase_completion>

<failure_handler name="review_phase_failed">
  <actions>
    - LOG: "PEER Review failed for cycle [CYCLE_NUMBER]"
    - UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].status = "REVIEW_FAILED"
    - UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].failed_at = "[TIMESTAMP]"
    - DISPLAY: "❌ Review phase failed. Check subagent output for details."
    - NOTE: "Cycle execution completed but review failed - results are still valid"
    - PROCEED: To cycle completion with partial success
  </actions>
</failure_handler>

</step>
  
<step number="11" name="cycle_completion">

### Step 11: Finalize PEER Cycle

Complete the PEER cycle by updating final state, performing cleanup, and providing summary.

<completion_tasks>
  UPDATE: Cycle status to "completed"
  RECORD: Completion timestamp
  SUMMARIZE: Key outcomes from all phases
  CLEANUP: Remove intermediate artifacts
  ARCHIVE: Compact cycle data for long-term storage
</completion_tasks>

<cycle_finalization>
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].status = "completed"
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].completed_at = "[TIMESTAMP]"
  UPDATE in NATS KV: [KEY_PREFIX].cycle.[CYCLE_NUMBER].metadata.phases_completed = ["planning", "execution", "express", "review"]
</cycle_finalization>

<cleanup_operations>
  - KEEP: Final results at [KEY_PREFIX].cycle.[CYCLE_NUMBER].deliverables
  - KEEP: Review insights at [KEY_PREFIX].cycle.[CYCLE_NUMBER].improvements
  - KEEP: Express summary at [KEY_PREFIX].cycle.[CYCLE_NUMBER].express_summary
  - ARCHIVE: Full cycle data to [KEY_PREFIX].archive.cycle.[CYCLE_NUMBER]
  - REMOVE: Temporary execution artifacts if any
</cleanup_operations>

<final_summary>
  ## PEER Cycle [CYCLE_NUMBER] Complete

  **Instruction:** [INSTRUCTION_NAME]
  **Spec:** [SPEC_NAME] (if applicable)
  
  ✅ Planning phase completed
  ✅ Execution phase completed
  ✅ Express phase completed
  ✅ Review phase completed
  
  Key deliverables stored at: [KEY_PREFIX].cycle.[CYCLE_NUMBER].deliverables
  Improvement insights at: [KEY_PREFIX].cycle.[CYCLE_NUMBER].improvements
  
  All outputs preserved in NATS KV under: [KEY_PREFIX].cycle.[CYCLE_NUMBER]
</final_summary>

<instructions>
  ACTION: Finalize PEER cycle
  UPDATE: Cycle status to completed
  CLEANUP: Intermediate artifacts while preserving results
  PROVIDE: Summary of completed work
  ARCHIVE: Cycle data for future reference
</instructions>

</step>

</process_flow>

## Execution Standards

- All logic expressed through process flow
- No external script dependencies
- State managed through NATS KV with dot-separated keys
- Clear error messages and recovery paths
- Comprehensive phase validation
- Atomicity through subagent-led persistence
- Professional output formatting
- Continuous improvement through review

## Storage Patterns

<key_format>
  Pattern: peer.{context}.cycle.{number}.{category}.{field}
  Example: peer.spec.user-auth.cycle.42.context.peer_mode
</key_format>

<atomicity_pattern>
  Subagents persist results directly to NATS KV
  Coordinator polls/waits for completion keys
  Work is "done" only when results are persisted
</atomicity_pattern>

## Error Handling

<error_principles>
  - Stop execution on critical errors
  - Provide clear error messages
  - Include recovery instructions
  - Document partial completions
  - Enable continuation when possible
  - Update failure states in NATS KV
</error_principles>

<failure_states>
  - PLANNING_FAILED
  - EXECUTION_FAILED
  - EXPRESS_FAILED
  - REVIEW_FAILED (non-critical)
</failure_states>

## Final Checklist

<verify>
  - [ ] NATS server available
  - [ ] KV bucket configured
  - [ ] Arguments validated
  - [ ] Context determined
  - [ ] Cycle initialized
  - [ ] All phases executed with atomicity
  - [ ] Results persisted by subagents
  - [ ] Review completed or handled
  - [ ] Cycle finalized with cleanup
</verify>
