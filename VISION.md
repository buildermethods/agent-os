# Project Vision: QA Agent OS

This document outlines the core vision, architecture, and workflow for the QA Agent OS project. It serves as a foundational reference to ensure development aligns with the project's primary goals.

## 1. High-Level Goal

The `qa-agent-os` is a distributable, spec-driven system designed to provide AI coding assistants (initially focusing on Claude) with the structured context they need to perform production-quality Quality Assurance tasks. It transforms an AI's generic capabilities into a specialized, expert QA assistant tailored to a specific project's needs.

## 2. Core Methodology: The 3-Layer Context System

The project is a direct implementation of the **Agent OS** methodology, which is built on a 3-layer context system. This system ensures the AI has a deep understanding of the project's standards, goals, and immediate tasks.

### Layer 1: Standards - *How* We Build

-   **Purpose:** To define the fundamental rules and quality guidelines for all QA work. This includes test case formats, bug reporting standards, severity rules, and analysis checklists.
-   **Source:** This content is created and maintained within the `qa-agent-os` source repository, specifically in the `profiles/default/standards/` directory.
-   **Implementation:** During the `project-install` step, these standards are compiled and copied into the end-user's project (`qa-agent-os/standards/`), providing the AI with its foundational knowledge.

### Layer 2: Product - *What* We're Building and *Why*

-   **Purpose:** To give the AI a high-level understanding of the specific project or team's mission, scope, and long-term vision. This prevents the AI from working in a vacuum and ensures its output aligns with business goals.
-   **Source:** This context is generated by the end-user (a QA engineer) within their own project by running the `/plan-product` command.
-   **Implementation:** The output of this command is stored within the user's project directory (e.g., `~/company-project/qa-agent-os/product/mission.md`), creating a persistent "brain" for the AI regarding that specific product area.

### Layer 3: Specs - *What* We're Building *Next*

-   **Purpose:** To provide the AI with the detailed, granular specifications for the immediate task at hand. We refer to this layer as `features`.
-   **Source:** This is generated by the QA engineer as they work on features and tickets, using the `/analise-requirements` command.
-   **Implementation:** This follows the **Product -> Feature -> Ticket** hierarchy. The agent, guided by the user, creates a structured set of directories and files within the main context folder (e.g., `~/company-project/qa-agent-os/features/<feature-name>/<ticket-id>/details.md`) to manage the specific requirements and generated test cases for each piece of work.

## 3. The End-User Workflow

The entire system is designed around a clear, three-step workflow for the end-user (a QA engineer).

**Step 1: Base Installation**
The user performs a one-time installation of the core `qa-agent-os` system onto their local machine, which places the master scripts and profiles in their home directory (e.g., `~/qa-agent-os`).

```bash
# User runs the installation command
curl -sSL https://raw.githubusercontent.com/Edmundo-Figueroa/qa-agent-os/main/scripts/base-install.sh | bash
```

**Step 2: Project Installation**
For every company project they work on, the user navigates into that project's directory and runs the `project-install.sh` script.

```bash
cd ~/company-project-A/
~/qa-agent-os/scripts/project-install.sh
```
This compiles the **Standards** into a project-specific `qa-agent-os/` folder and creates the LLM-specific command directory, `.claude/`.

**Step 3: Day-to-Day Usage**
The user works within their project directory using their preferred AI tool (e.g., a Claude-enabled editor or CLI). The tool uses the context from both the `.claude/` and `qa-agent-os/` folders to understand its commands and the project's context.

-   They run `/plan-product` to define the **Product** context.
-   They run `/analise-requirements` to create and analyze **Specs** (as `features`) for their tickets.

## 4. Example Directory Structure (User's Project)

After installation and some use, a QA engineer's project directory will look like this:

```
~/company-project-A/
├── .claude/
│   ├── agents/
│   │   ├── product-planner.md     <-- Compiled from qa-agent-os base install
│   │   └── requirement-analyst.md <-- Compiled from qa-agent-os base install
│   └── commands/
│       ├── plan-product.md        <-- Compiled from qa-agent-os base install
│       └── analise-requirements.md  <-- Compiled from qa-agent-os base install
│
├── qa-agent-os/
│   ├── product/
│   │   └── mission.md             <-- Generated by /plan-product command
│   ├── standards/
│   │   ├── bug-reporting.md       <-- Copied during installation
│   │   └── test-cases.md          <-- Copied during installation
│   └── features/                  <-- Our equivalent of "specs", nested inside
│       └── 2025-11-17-TWRR/.   // YYYY-MM-DD-feature-name , should be created after run /init-feature TWRR 
│           ├── documentation/
│           │   ├── BRD.md
│           │   ├── mockups.png
│           └── TWRR-123/
│               ├── planing/
│               │    └── requirements.md <-- Generated by /analise-requirements
│               ├── artifacts/
│                   ├── csv.md         <-- Generated by /export-csv [optional]
│                   └── testcases.md   <-- Generated by /generate-testcases
│
└── src/
    └── ... (The actual source code of the company's project)
```
